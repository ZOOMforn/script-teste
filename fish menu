-- ==================== DELAY INICIAL ====================
task.wait(3)

-- ==================== SERVIÃ‡OS ====================
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer

-- ==================== DETECÃ‡ÃƒO DE PLATAFORMA ====================
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local isPC = not isMobile

-- ==================== LIMPEZA SILENCIOSA ====================
pcall(function()
    for _, v in pairs(CoreGui:GetChildren()) do
        if v.Name:find("Fisch Menu") or v.Name:find("Fisch MenuUI") or v.Name == "Fisch MenuMainUI" then
            v:Destroy()
        end
    end
    
    local PlayerGui = Player:WaitForChild("PlayerGui")
    for _, v in pairs(PlayerGui:GetChildren()) do
        if v.Name:find("Fisch Menu") or v.Name:find("Fisch MenuUI") or v.Name == "Fisch MenuMainUI" then
            v:Destroy()
        end
    end
end)

task.wait(0.5)

-- ==================== CONFIG MANAGER ====================
local ConfigManager = {}
ConfigManager.ConfigPath = "Fish Menu"
ConfigManager.CurrentConfig = {
    Theme = {
        Color = {220, 60, 60},
        Rainbow = false,
        Transparency = 0
    },
    Keybind = {
        Type = "KeyCode",
        Value = "RightShift"
    },
    Settings = {}
}

function ConfigManager:SaveConfig()
    local hasFileAccess = pcall(function() 
        return readfile and writefile and isfile 
    end)
    
    if not hasFileAccess then return false end
    
    local success = pcall(function()
        local json = HttpService:JSONEncode(self.CurrentConfig)
        writefile(self.ConfigPath, json)
    end)
    
    return success
end

function ConfigManager:LoadConfig()
    local hasFileAccess = pcall(function() 
        return readfile and writefile and isfile 
    end)
    
    if not hasFileAccess then return false end
    
    local success = pcall(function()
        if isfile(self.ConfigPath) then
            local data = readfile(self.ConfigPath)
            local decoded = HttpService:JSONDecode(data)
            
            for key, value in pairs(decoded) do
                if type(self.CurrentConfig[key]) == "table" and type(value) == "table" then
                    for k, v in pairs(value) do
                        self.CurrentConfig[key][k] = v
                    end
                else
                    self.CurrentConfig[key] = value
                end
            end
        end
    end)
    
    return success
end

function ConfigManager:UpdateSetting(key, value)
    self.CurrentConfig.Settings[key] = value
end

function ConfigManager:GetSetting(key, default)
    local val = self.CurrentConfig.Settings[key]
    return val ~= nil and val or default
end

ConfigManager:LoadConfig()

-- ==================== INPUT HANDLER ====================
local InputHandler = {}
InputHandler.CurrentBind = nil
InputHandler.BindType = nil

function InputHandler:StringToInput(inputType, value)
    if inputType == "KeyCode" then
        return Enum.KeyCode[value]
    elseif inputType == "UserInputType" then
        return Enum.UserInputType[value]
    end
    return nil
end

function InputHandler:InputToString(input)
    if typeof(input) == "EnumItem" then
        return input.Name
    end
    return tostring(input)
end

function InputHandler:SetBinding(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        self.BindType = "KeyCode"
        self.CurrentBind = input.KeyCode
    else
        self.BindType = "UserInputType"
        self.CurrentBind = input.UserInputType
    end
    
    ConfigManager.CurrentConfig.Keybind = {
        Type = self.BindType,
        Value = self:InputToString(self.CurrentBind)
    }
    
    return self:GetBindName()
end

function InputHandler:GetBindName()
    if self.CurrentBind then
        return self:InputToString(self.CurrentBind)
    end
    return "None"
end

local savedBind = ConfigManager.CurrentConfig.Keybind
if savedBind and savedBind.Type and savedBind.Value then
    InputHandler.BindType = savedBind.Type
    InputHandler.CurrentBind = InputHandler:StringToInput(savedBind.Type, savedBind.Value)
else
    InputHandler.BindType = "KeyCode"
    InputHandler.CurrentBind = Enum.KeyCode.RightShift
end

-- ==================== CRIAR UI ====================
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Fisch Menu"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.DisplayOrder = 999
ScreenGui.IgnoreGuiInset = true

local function injectGui()
    local success = pcall(function()
        ScreenGui.Parent = CoreGui
    end)
    
    if not success or not ScreenGui.Parent then
        pcall(function()
            ScreenGui.Parent = Player:WaitForChild("PlayerGui")
        end)
    end
    
    ScreenGui.AncestryChanged:Connect(function(_, parent)
        if not parent then
            task.wait(0.5)
            pcall(function()
                ScreenGui.Parent = CoreGui
            end)
        end
    end)
end

injectGui()

-- VARIÃVEIS GLOBAIS
local ThemeColor = Color3.fromRGB(unpack(ConfigManager.CurrentConfig.Theme.Color))
local RainbowEnabled = ConfigManager.CurrentConfig.Theme.Rainbow
local UITransparency = ConfigManager.CurrentConfig.Theme.Transparency
local RainbowLoop = nil

local ColoredElements = {
    Backgrounds = setmetatable({}, {__mode = "v"}),
    Strokes = setmetatable({}, {__mode = "v"}),
    ScrollBars = setmetatable({}, {__mode = "v"}),
    TextLabels = setmetatable({}, {__mode = "v"}),
    ActiveToggles = setmetatable({}, {__mode = "v"})
}

local function AddColoredElement(element, elementType)
    if not element then return end
    elementType = elementType or "Backgrounds"
    table.insert(ColoredElements[elementType], element)
end

local function Tween(obj, props, time)
    if not obj or not obj.Parent then return end
    local tween = TweenService:Create(obj, TweenInfo.new(time or 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), props)
    tween:Play()
    return tween
end

local function UpdateThemeColor(newColor, instant)
    ThemeColor = newColor
    ConfigManager.CurrentConfig.Theme.Color = {math.floor(newColor.R * 255), math.floor(newColor.G * 255), math.floor(newColor.B * 255)}
    
    local updateFunc = instant and function(elem, prop, color)
        pcall(function()
            if elem and elem.Parent then elem[prop] = color end
        end)
    end or function(elem, prop, color)
        pcall(function()
            if elem and elem.Parent then Tween(elem, {[prop] = color}, 0.3) end
        end)
    end
    
    for _, element in pairs(ColoredElements.Backgrounds) do
        updateFunc(element, "BackgroundColor3", newColor)
    end
    for _, element in pairs(ColoredElements.Strokes) do
        updateFunc(element, "Color", newColor)
    end
    for _, element in pairs(ColoredElements.ScrollBars) do
        updateFunc(element, "ScrollBarImageColor3", newColor)
    end
    for _, element in pairs(ColoredElements.TextLabels) do
        updateFunc(element, "TextColor3", newColor)
    end
    for _, toggleBG in pairs(ColoredElements.ActiveToggles) do
        updateFunc(toggleBG, "BackgroundColor3", newColor)
    end
end

-- ==================== BOTÃƒO MÃ“VEL PARA ABRIR/FECHAR GUI ====================
local MobileButton = Instance.new("ImageButton")
MobileButton.Name = "MobileMenuButton"
MobileButton.Size = UDim2.new(0, 50, 0, 50)
MobileButton.Position = UDim2.new(1, -70, 0.5, -25)
MobileButton.AnchorPoint = Vector2.new(1, 0.5)
MobileButton.BackgroundColor3 = ThemeColor
MobileButton.BackgroundTransparency = 0.3
MobileButton.Image = "rbxassetid://3926305904" -- Ãcone de menu (substitua pelo ID da imagem que quiser)
MobileButton.ImageRectSize = Vector2.new(36, 36)
MobileButton.ImageRectOffset = Vector2.new(964, 324)
MobileButton.Parent = ScreenGui

local MobileButtonCorner = Instance.new("UICorner")
MobileButtonCorner.CornerRadius = UDim.new(1, 0)
MobileButtonCorner.Parent = MobileButton

local MobileButtonStroke = Instance.new("UIStroke")
MobileButtonStroke.Color = Color3.fromRGB(255, 255, 255)
MobileButtonStroke.Thickness = 2
MobileButtonStroke.Parent = MobileButton

-- Tornar o botÃ£o mÃ³vel
local mobileDragging, mobileDragInput, mobileDragStart, mobileStartPos

MobileButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or 
       input.UserInputType == Enum.UserInputType.Touch then
        mobileDragging = true
        mobileDragStart = input.Position
        mobileStartPos = MobileButton.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                mobileDragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseMovement or 
        input.UserInputType == Enum.UserInputType.Touch) and mobileDragging then
        local delta = input.Position - mobileDragStart
        MobileButton.Position = UDim2.new(
            mobileStartPos.X.Scale, 
            mobileStartPos.X.Offset + delta.X,
            mobileStartPos.Y.Scale, 
            mobileStartPos.Y.Offset + delta.Y
        )
    end
end)

-- ==================== CRIAR UI PRINCIPAL (NÃƒO MOVÃVEL) ====================
local Main = Instance.new("Frame")
Main.Name = "MainFrame"
Main.Size = UDim2.new(0, 0, 0, 0)
Main.Position = UDim2.new(0.5, 0, 0.5, 0)
Main.AnchorPoint = Vector2.new(0.5, 0.5)
Main.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
Main.BackgroundTransparency = 0.1
Main.BorderSizePixel = 0
Main.Active = true
Main.Visible = false
Main.Parent = ScreenGui

-- REMOVER A FUNÃ‡ÃƒO MakeDraggable DA MAIN (para que ela nÃ£o seja mÃ³vel)
-- Mantemos apenas o TopBar por estÃ©tica, mas sem funÃ§Ã£o de arrastar
local TopBar = Instance.new("Frame")
TopBar.Name = "TopBar"
TopBar.Size = UDim2.new(1, 0, 0, 40)
TopBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
TopBar.BorderSizePixel = 0
TopBar.Parent = Main

local TopBarCorner = Instance.new("UICorner")
TopBarCorner.CornerRadius = UDim.new(0, 10)
TopBarCorner.Parent = TopBar

local TopBarCover = Instance.new("Frame")
TopBarCover.Size = UDim2.new(1, 0, 0, 20)
TopBarCover.Position = UDim2.new(0, 0, 1, -20)
TopBarCover.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
TopBarCover.BorderSizePixel = 0
TopBarCover.Parent = TopBar

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(0, 250, 1, 0)
Title.Position = UDim2.new(0, 15, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Fisch Menu by @zoom_forn"
Title.Font = Enum.Font.FredokaOne
Title.TextSize = 14
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = TopBar

local CloseBtn = Instance.new("TextButton")
CloseBtn.Size = UDim2.new(0, 35, 0, 35)
CloseBtn.Position = UDim2.new(1, -40, 0.5, -17.5)
CloseBtn.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
CloseBtn.BorderSizePixel = 0
CloseBtn.Text = "x"
CloseBtn.Font = Enum.Font.FredokaOne
CloseBtn.TextSize = 16
CloseBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
CloseBtn.AutoButtonColor = false
CloseBtn.Parent = TopBar

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 8)
CloseCorner.Parent = CloseBtn

CloseBtn.MouseButton1Click:Connect(function()
    ConfigManager:SaveConfig()
    Tween(Main, {Size = UDim2.new(0, 0, 0, 0)})
    task.wait(0.5)
    Main.Visible = false
end)

-- Configurar o botÃ£o mÃ³vel para mostrar/esconder a GUI
MobileButton.MouseButton1Click:Connect(function()
    if Main.Visible then
        -- Esconder a GUI
        Tween(Main, {Size = UDim2.new(0, 0, 0, 0)}, 0.3)
        task.wait(0.3)
        Main.Visible = false
    else
        -- Mostrar a GUI
        Main.Visible = true
        Tween(Main, {Size = UDim2.new(0.45, 0, 0.65, 0)}, 0.3)
    end
end)

-- ==================== RESTANTE DO CÃ“DIGO (igual ao original) ====================
-- ... [O RESTANTE DO CÃ“DIGO PERMANECE EXATAMENTE IGUAL] ...

-- Continuar com o cÃ³digo existente (a partir da linha onde comeÃ§a o Blur):
local Blur = Instance.new("ImageLabel")
Blur.Name = "Blur"
Blur.Size = UDim2.new(1, 0, 1, 0)
Blur.BackgroundTransparency = 1
Blur.Image = "rbxassetid://114886935519572"
Blur.ImageTransparency = 0.7
Blur.ScaleType = Enum.ScaleType.Slice
Blur.SliceCenter = Rect.new(10, 10, 10, 10)
Blur.ZIndex = -1
Blur.Parent = Main

local SizeConstraint = Instance.new("UISizeConstraint")
SizeConstraint.MinSize = Vector2.new(400, 350)
SizeConstraint.MaxSize = Vector2.new(1200, 900)
SizeConstraint.Parent = Main

local MainCorner = Instance.new("UICorner")
MainCorner.CornerRadius = UDim.new(0, 10)
MainCorner.Parent = Main

local BorderGlow = Instance.new("UIStroke")
BorderGlow.Color = ThemeColor
BorderGlow.Thickness = 1
BorderGlow.Transparency = 0.5
BorderGlow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
BorderGlow.Parent = Main
AddColoredElement(BorderGlow, "Strokes")

task.spawn(function()
    task.wait(0.5)
    -- A GUI nÃ£o aparece automaticamente mais
    -- Main.Visible = true
    -- Tween(Main, {Size = UDim2.new(0.45, 0, 0.65, 0)}, 0.5)
end)

local RightSide = Instance.new("Frame")
RightSide.Size = UDim2.new(1, 0, 1, -40)
RightSide.Position = UDim2.new(0, 0, 0, 40)
RightSide.BackgroundTransparency = 1
RightSide.Parent = Main
 
-- ==================== TABS BAR COM SCROLL HORIZONTAL ====================
local TabsBar = Instance.new("Frame")
TabsBar.Size = UDim2.new(1, 0, 0, 45)
TabsBar.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
TabsBar.BorderSizePixel = 0
TabsBar.Parent = RightSide

local TabsScroll = Instance.new("ScrollingFrame")
TabsScroll.Name = "TabsScroll"
TabsScroll.Size = UDim2.new(1, -10, 1, 0)
TabsScroll.Position = UDim2.new(0, 5, 0, 0)
TabsScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
TabsScroll.ScrollBarThickness = 0
TabsScroll.ScrollBarImageTransparency = 1
TabsScroll.ScrollingDirection = Enum.ScrollingDirection.X
TabsScroll.AutomaticCanvasSize = Enum.AutomaticSize.None
TabsScroll.BackgroundTransparency = 1
TabsScroll.BorderSizePixel = 0
TabsScroll.Parent = TabsBar

AddColoredElement(TabsScroll, "ScrollBars")

local TabsList = Instance.new("UIListLayout")
TabsList.FillDirection = Enum.FillDirection.Horizontal
TabsList.SortOrder = Enum.SortOrder.LayoutOrder
TabsList.Padding = UDim.new(0, 6)
TabsList.Parent = TabsScroll

TabsList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    TabsScroll.CanvasSize = UDim2.new(0, TabsList.AbsoluteContentSize.X + 10, 0, 0)
end)

local ContentArea = Instance.new("Frame")
ContentArea.Size = UDim2.new(1, 0, 1, -45)
ContentArea.Position = UDim2.new(0, 0, 0, 45)
ContentArea.BackgroundTransparency = 1
ContentArea.Parent = RightSide

-- ==================== KEYBIND TOGGLE ====================
local UIToggleConnection = nil

local function SetupUIToggle()
    if UIToggleConnection then
        pcall(function() UIToggleConnection:Disconnect() end)
        UIToggleConnection = nil
    end
    
    UIToggleConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        local matches = false
        
        if InputHandler.BindType == "KeyCode" then
            if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == InputHandler.CurrentBind then
                matches = true
            end
        elseif InputHandler.BindType == "UserInputType" then
            if input.UserInputType == InputHandler.CurrentBind then
                matches = true
            end
        end
        
        if matches then
            if Main.Visible then
                -- Esconder a GUI
                Tween(Main, {Size = UDim2.new(0, 0, 0, 0)}, 0.3)
                task.wait(0.3)
                Main.Visible = false
            else
                -- Mostrar a GUI
                Main.Visible = true
                Tween(Main, {Size = UDim2.new(0.45, 0, 0.65, 0)}, 0.3)
            end
        end
    end)
end

SetupUIToggle()

ScreenGui.Destroying:Connect(function()
    ConfigManager:SaveConfig()
end)

-- ==================== LIBRARY ====================
local Library = {}

local function ResetAllTabs()
    for _, obj in ipairs(TabsScroll:GetChildren()) do
        if obj:IsA("TextButton") then
            Tween(obj, {BackgroundColor3 = Color3.fromRGB(18, 18, 18)})
            Tween(obj, {TextColor3 = Color3.fromRGB(130, 130, 130)})

            local ind = obj:FindFirstChild("Indicator")
            if ind then
                ind.Visible = false
            end
        end
    end
end


function Library:CreateTab(name)
    local Tab = {}
    
    local TabBtn = Instance.new("TextButton")
    TabBtn.Name = "TabButton"
    TabBtn.Size = UDim2.new(0, 110, 1, -8)
    TabBtn.Position = UDim2.new(0, 0, 0, 4)
    TabBtn.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
    TabBtn.BorderSizePixel = 0
    TabBtn.AutoButtonColor = false
    TabBtn.Text = name
    TabBtn.Font = Enum.Font.FredokaOne
    TabBtn.TextSize = 11
    TabBtn.TextColor3 = Color3.fromRGB(130, 130, 130)
    TabBtn.Parent = TabsScroll
    
    local TabCorner = Instance.new("UICorner")
    TabCorner.CornerRadius = UDim.new(0, 6)
    TabCorner.Parent = TabBtn
    
    local Indicator = Instance.new("Frame")
    Indicator.Name = "Indicator"
    Indicator.Size = UDim2.new(1, -4, 0, 3)
    Indicator.Position = UDim2.new(0, 2, 1, -5)
    Indicator.BackgroundColor3 = ThemeColor
    Indicator.BorderSizePixel = 0
    Indicator.Visible = false
    Indicator.Parent = TabBtn
    AddColoredElement(Indicator, "Backgrounds")
    
    local IndCorner = Instance.new("UICorner")
    IndCorner.CornerRadius = UDim.new(1, 0)
    IndCorner.Parent = Indicator
    
    local TabContent = Instance.new("Frame")
    TabContent.Name = "TabContent"
    TabContent.Size = UDim2.new(1, 0, 1, 0)
    TabContent.BackgroundTransparency = 1
    TabContent.Visible = false
    TabContent.Parent = ContentArea
    
    local LeftCol = Instance.new("ScrollingFrame")
    LeftCol.Name = "LeftColumn"
    LeftCol.Size = UDim2.new(0.5, -10, 1, -15)
    LeftCol.Position = UDim2.new(0, 8, 0, 8)
    LeftCol.BackgroundTransparency = 1
    LeftCol.BorderSizePixel = 0
    LeftCol.ScrollBarThickness = 4
    LeftCol.ScrollBarImageColor3 = ThemeColor
    LeftCol.CanvasSize = UDim2.new(0, 0, 0, 0)
    LeftCol.Parent = TabContent
    AddColoredElement(LeftCol, "ScrollBars")
    
    local LeftList = Instance.new("UIListLayout")
    LeftList.Padding = UDim.new(0, 5)
    LeftList.SortOrder = Enum.SortOrder.LayoutOrder
    LeftList.Parent = LeftCol
    
    LeftList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        LeftCol.CanvasSize = UDim2.new(0, 0, 0, LeftList.AbsoluteContentSize.Y + 10)
    end)
    
    local RightCol = Instance.new("ScrollingFrame")
    RightCol.Name = "RightColumn"
    RightCol.Size = UDim2.new(0.5, -10, 1, -15)
    RightCol.Position = UDim2.new(0.5, 2, 0, 8)
    RightCol.BackgroundTransparency = 1
    RightCol.BorderSizePixel = 0
    RightCol.ScrollBarThickness = 4
    RightCol.ScrollBarImageColor3 = ThemeColor
    RightCol.CanvasSize = UDim2.new(0, 0, 0, 0)
    RightCol.Parent = TabContent
    AddColoredElement(RightCol, "ScrollBars")
    
    local RightList = Instance.new("UIListLayout")
    RightList.Padding = UDim.new(0, 5)
    RightList.SortOrder = Enum.SortOrder.LayoutOrder
    RightList.Parent = RightCol
    
    RightList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        RightCol.CanvasSize = UDim2.new(0, 0, 0, RightList.AbsoluteContentSize.Y + 10)
    end)
    
    local currentColumn = LeftCol
    
TabBtn.MouseButton1Click:Connect(function()
    -- evita reprocessar se jÃ¡ estiver ativa
    if Indicator.Visible then return end

    -- esconde todo conteÃºdo
    for _, frame in ipairs(ContentArea:GetChildren()) do
        if frame:IsA("Frame") then
            frame.Visible = false
        end
    end

    -- reseta todas as tabs (FIX)
    ResetAllTabs()

    -- ativa essa tab
    TabContent.Visible = true
    Indicator.Visible = true

    Tween(TabBtn, {BackgroundColor3 = Color3.fromRGB(25, 25, 25)})
    Tween(TabBtn, {TextColor3 = Color3.fromRGB(255, 255, 255)})
end)

    
    function Tab:AddSection(text, side)
        if side == "left" then currentColumn = LeftCol
        elseif side == "right" then currentColumn = RightCol end
        
        local Section = Instance.new("Frame")
        Section.Size = UDim2.new(1, 0, 0, 32)
        Section.BackgroundTransparency = 1
        Section.Parent = currentColumn
        
        local Line = Instance.new("Frame")
        Line.Size = UDim2.new(0, 3, 0, 18)
        Line.Position = UDim2.new(0, 0, 0.5, -9)
        Line.BackgroundColor3 = ThemeColor
        Line.BorderSizePixel = 0
        Line.Parent = Section
        AddColoredElement(Line, "Backgrounds")
        
        local LineCorner = Instance.new("UICorner")
        LineCorner.CornerRadius = UDim.new(1, 0)
        LineCorner.Parent = Line
        
        local Label = Instance.new("TextLabel")
        Label.Size = UDim2.new(1, -10, 1, 0)
        Label.Position = UDim2.new(0, 10, 0, 0)
        Label.BackgroundTransparency = 1
        Label.Text = text
        Label.Font = Enum.Font.FredokaOne
        Label.TextSize = 12
        Label.TextColor3 = Color3.fromRGB(230, 230, 230)
        Label.TextXAlignment = Enum.TextXAlignment.Left
        Label.Parent = Section
        
        return Section
    end
    
function Tab:AddToggle(text, default, callback)
    local toggleKey = "Toggle_" .. text:gsub(" ", "_")
    local enabled = ConfigManager:GetSetting(toggleKey, default or false)
    local initialized = false -- evita callback duplicado

    local Toggle = Instance.new("Frame")
    Toggle.Size = UDim2.new(1, 0, 0, 32)
    Toggle.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Toggle.BorderSizePixel = 0
    Toggle.Parent = currentColumn

    local ToggleCorner = Instance.new("UICorner")
    ToggleCorner.CornerRadius = UDim.new(0, 6)
    ToggleCorner.Parent = Toggle

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(1, -55, 1, 0)
    Label.Position = UDim2.new(0, 10, 0, 0)
    Label.BackgroundTransparency = 1
    Label.Text = text
    Label.Font = Enum.Font.FredokaOne
    Label.TextSize = 11
    Label.TextColor3 = Color3.fromRGB(190, 190, 190)
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.Parent = Toggle

    local ToggleBG = Instance.new("Frame")
    ToggleBG.Size = UDim2.new(0, 42, 0, 20)
    ToggleBG.Position = UDim2.new(1, -47, 0.5, -10)
    ToggleBG.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    ToggleBG.BorderSizePixel = 0
    ToggleBG.Parent = Toggle

    local TBGCorner = Instance.new("UICorner")
    TBGCorner.CornerRadius = UDim.new(1, 0)
    TBGCorner.Parent = ToggleBG

    local Circle = Instance.new("Frame")
    Circle.Size = UDim2.new(0, 16, 0, 16)
    Circle.Position = UDim2.new(0, 2, 0.5, -8)
    Circle.BackgroundColor3 = Color3.fromRGB(160, 160, 160)
    Circle.BorderSizePixel = 0
    Circle.Parent = ToggleBG

    local CircleCorner = Instance.new("UICorner")
    CircleCorner.CornerRadius = UDim.new(1, 0)
    CircleCorner.Parent = Circle

    local function Update()
        if enabled then
            ToggleBG.BackgroundColor3 = ThemeColor
            Tween(Circle, { Position = UDim2.new(1, -18, 0.5, -8) }, 0.15)
            Tween(Circle, { BackgroundColor3 = Color3.fromRGB(255, 255, 255) }, 0.15)
            Tween(Label, { TextColor3 = Color3.fromRGB(220, 220, 220) }, 0.15)

            if not table.find(ColoredElements.ActiveToggles, ToggleBG) then
                table.insert(ColoredElements.ActiveToggles, ToggleBG)
            end
        else
            Tween(ToggleBG, { BackgroundColor3 = Color3.fromRGB(35, 35, 35) }, 0.15)
            Tween(Circle, { Position = UDim2.new(0, 2, 0.5, -8) }, 0.15)
            Tween(Circle, { BackgroundColor3 = Color3.fromRGB(160, 160, 160) }, 0.15)
            Tween(Label, { TextColor3 = Color3.fromRGB(190, 190, 190) }, 0.15)

            local index = table.find(ColoredElements.ActiveToggles, ToggleBG)
            if index then
                table.remove(ColoredElements.ActiveToggles, index)
            end
        end
    end

    -- aplica estado visual
    Update()

    -- ðŸ”¥ aplica estado lÃ³gico salvo (ao carregar)
    task.defer(function()
        if enabled and callback and not initialized then
            initialized = true
            local ok, err = pcall(callback, true)
            if not ok then
                warn("âŒ Erro no callback Toggle (init):", err)
            end
        end
    end)

    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(1, 0, 1, 0)
    Button.BackgroundTransparency = 1
    Button.Text = ""
    Button.Parent = Toggle

    Button.MouseButton1Click:Connect(function()
        enabled = not enabled
        Update()
        ConfigManager:UpdateSetting(toggleKey, enabled)

        if callback then
            local ok, err = pcall(callback, enabled)
            if not ok then
                warn("âŒ Erro no callback Toggle:", err)
            end
        end
    end)

    return Toggle
end

    function Tab:AddSlider(text, min, max, default, callback)
        local sliderKey = "Slider_" .. text:gsub(" ", "_")
        local value = ConfigManager:GetSetting(sliderKey, default)

        local Slider = Instance.new("Frame")
        Slider.Size = UDim2.new(1, 0, 0, 55)
        Slider.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        Slider.BorderSizePixel = 0
        Slider.Parent = currentColumn

        local SliderCorner = Instance.new("UICorner")
        SliderCorner.CornerRadius = UDim.new(0, 6)
        SliderCorner.Parent = Slider

        local Label = Instance.new("TextLabel")
        Label.Size = UDim2.new(1, -55, 0, 22)
        Label.Position = UDim2.new(0, 10, 0, 5)
        Label.BackgroundTransparency = 1
        Label.Text = text
        Label.Font = Enum.Font.FredokaOne
        Label.TextSize = 11
        Label.TextColor3 = Color3.fromRGB(190, 190, 190)
        Label.TextXAlignment = Enum.TextXAlignment.Left
        Label.Parent = Slider

        local ValueLabel = Instance.new("TextLabel")
        ValueLabel.Size = UDim2.new(0, 50, 0, 22)
        ValueLabel.Position = UDim2.new(1, -55, 0, 5)
        ValueLabel.BackgroundTransparency = 1
        ValueLabel.Text = tostring(value)
        ValueLabel.Font = Enum.Font.FredokaOne
        ValueLabel.TextSize = 12
        ValueLabel.TextColor3 = ThemeColor
        ValueLabel.TextXAlignment = Enum.TextXAlignment.Right
        ValueLabel.Parent = Slider
        AddColoredElement(ValueLabel, "TextLabels")

        local SliderBG = Instance.new("Frame")
        SliderBG.Size = UDim2.new(1, -20, 0, 8)
        SliderBG.Position = UDim2.new(0, 10, 0, 35)
        SliderBG.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
        SliderBG.BorderSizePixel = 0
        SliderBG.Parent = Slider

        local SliderBGCorner = Instance.new("UICorner")
        SliderBGCorner.CornerRadius = UDim.new(1, 0)
        SliderBGCorner.Parent = SliderBG

        local SliderFill = Instance.new("Frame")
        SliderFill.Size = UDim2.new(0, 0, 1, 0)
        SliderFill.BackgroundColor3 = ThemeColor
        SliderFill.BorderSizePixel = 0
        SliderFill.Parent = SliderBG
        AddColoredElement(SliderFill, "Backgrounds")

        local SliderFillCorner = Instance.new("UICorner")
        SliderFillCorner.CornerRadius = UDim.new(1, 0)
        SliderFillCorner.Parent = SliderFill

        local SliderButton = Instance.new("Frame")
        SliderButton.Size = UDim2.new(0, 16, 0, 16)
        SliderButton.Position = UDim2.new(0, 0, 0.5, -8)
        SliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        SliderButton.BorderSizePixel = 0
        SliderButton.Parent = SliderBG

        local SliderButtonCorner = Instance.new("UICorner")
        SliderButtonCorner.CornerRadius = UDim.new(1, 0)
        SliderButtonCorner.Parent = SliderButton

        local SliderBtnStroke = Instance.new("UIStroke")
        SliderBtnStroke.Color = ThemeColor
        SliderBtnStroke.Thickness = 2
        SliderBtnStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        SliderBtnStroke.Parent = SliderButton
        AddColoredElement(SliderBtnStroke, "Strokes")

        local dragging = false

        local function Update(val)
            value = math.clamp(val, min, max)
            ValueLabel.Text = tostring(math.floor(value))

            local percent = (value - min) / (max - min)
            SliderFill.Size = UDim2.new(percent, 0, 1, 0)
            SliderButton.Position = UDim2.new(percent, -8, 0.5, -8)

            ConfigManager:UpdateSetting(sliderKey, value)
            if callback then
                pcall(callback, value)
            end
        end

        Update(value)

        SliderBG.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                Tween(SliderButton, {Size = UDim2.new(0, 20, 0, 20)}, 0.1)

                local posX = input.Position.X
                local sliderPos = SliderBG.AbsolutePosition.X
                local sliderSize = SliderBG.AbsoluteSize.X
                local percent = math.clamp((posX - sliderPos) / sliderSize, 0, 1)
                local newValue = min + (max - min) * percent
                Update(newValue)
            end
        end)

        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                if dragging then
                    dragging = false
                    Tween(SliderButton, {Size = UDim2.new(0, 16, 0, 16)}, 0.1)
                end
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local posX = input.Position.X
                local sliderPos = SliderBG.AbsolutePosition.X
                local sliderSize = SliderBG.AbsoluteSize.X
                local percent = math.clamp((posX - sliderPos) / sliderSize, 0, 1)
                local newValue = min + (max - min) * percent
                Update(newValue)
            end
        end)

        return Slider
    end
    
    function Tab:AddDropdown(text, options, default, callback)
        local dropdownKey = "Dropdown_" .. text:gsub(" ", "_")
        local selected = ConfigManager:GetSetting(dropdownKey, default or options[1])
        
        local Dropdown = Instance.new("Frame")
        Dropdown.Size = UDim2.new(1, 0, 0, 32)
        Dropdown.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        Dropdown.BorderSizePixel = 0
        Dropdown.Parent = currentColumn
        Dropdown.ZIndex = 1000

        local DropdownCorner = Instance.new("UICorner")
        DropdownCorner.CornerRadius = UDim.new(0, 6)
        DropdownCorner.Parent = Dropdown

        local Label = Instance.new("TextLabel")
        Label.Size = UDim2.new(0, 120, 1, 0)
        Label.Position = UDim2.new(0, 10, 0, 0)
        Label.BackgroundTransparency = 1
        Label.Text = text
        Label.Font = Enum.Font.FredokaOne
        Label.TextSize = 11
        Label.TextColor3 = Color3.fromRGB(190, 190, 190)
        Label.TextXAlignment = Enum.TextXAlignment.Left
        Label.Parent = Dropdown
        Label.ZIndex = 1001

        local DropBtn = Instance.new("TextButton")
        DropBtn.Size = UDim2.new(1, -140, 0, 22)
        DropBtn.Position = UDim2.new(0, 135, 0.5, -11)
        DropBtn.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        DropBtn.BorderSizePixel = 0
        DropBtn.Text = selected .. " â–¼"
        DropBtn.Font = Enum.Font.FredokaOne
        DropBtn.TextSize = 10
        DropBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
        DropBtn.AutoButtonColor = false
        DropBtn.Parent = Dropdown
        DropBtn.ZIndex = 1001

        local DropBtnCorner = Instance.new("UICorner")
        DropBtnCorner.CornerRadius = UDim.new(0, 4)
        DropBtnCorner.Parent = DropBtn

        local DropList = Instance.new("Frame")
        DropList.Size = UDim2.new(0, DropBtn.AbsoluteSize.X, 0, #options * 25)
        DropList.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        DropList.BorderSizePixel = 0
        DropList.Visible = false
        DropList.ZIndex = 99999
        DropList.Parent = ScreenGui

        local DropListCorner = Instance.new("UICorner")
        DropListCorner.CornerRadius = UDim.new(0, 6)
        DropListCorner.Parent = DropList

        local DropListStroke = Instance.new("UIStroke")
        DropListStroke.Color = ThemeColor
        DropListStroke.Thickness = 1
        DropListStroke.Parent = DropList
        AddColoredElement(DropListStroke, "Strokes")

        local ListLayout = Instance.new("UIListLayout")
        ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        ListLayout.Parent = DropList

        local optionButtons = {}

        for i, option in ipairs(options) do
            local OptionBtn = Instance.new("TextButton")
            OptionBtn.Size = UDim2.new(1, 0, 0, 25)
            OptionBtn.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
            OptionBtn.BorderSizePixel = 0
            OptionBtn.Text = option
            OptionBtn.Font = Enum.Font.FredokaOne
            OptionBtn.TextSize = 10
            OptionBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
            OptionBtn.AutoButtonColor = false
            OptionBtn.Parent = DropList
            OptionBtn.ZIndex = 100000
            OptionBtn.LayoutOrder = i

            optionButtons[option] = OptionBtn

            OptionBtn.MouseEnter:Connect(function()
                if DropList.Visible then
                    Tween(OptionBtn, {BackgroundColor3 = Color3.fromRGB(30, 30, 30)})
                end
            end)
            
            OptionBtn.MouseLeave:Connect(function()
                if DropList.Visible then
                    Tween(OptionBtn, {BackgroundColor3 = Color3.fromRGB(15, 15, 15)})
                end
            end)
            
            OptionBtn.MouseButton1Click:Connect(function()
                selected = option
                DropBtn.Text = selected .. " â–¼"
                DropList.Visible = false
                
                for opt, btn in pairs(optionButtons) do
                    if opt == selected then
                        Tween(btn, {BackgroundColor3 = Color3.fromRGB(30, 30, 60)})
                        Tween(btn, {TextColor3 = Color3.fromRGB(255, 255, 255)})
                    else
                        Tween(btn, {BackgroundColor3 = Color3.fromRGB(15, 15, 15)})
                        Tween(btn, {TextColor3 = Color3.fromRGB(200, 200, 200)})
                    end
                end
                
                ConfigManager:UpdateSetting(dropdownKey, selected)
                
                if callback then 
                    pcall(callback, selected)
                end
            end)
        end

        ListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            DropList.Size = UDim2.new(0, DropBtn.AbsoluteSize.X, 0, ListLayout.AbsoluteContentSize.Y)
        end)

        local function updateDropdownPosition()
            local btnAbsolutePos = DropBtn.AbsolutePosition
            local btnSize = DropBtn.AbsoluteSize
            
            DropList.Position = UDim2.new(
                0, btnAbsolutePos.X,
                0, btnAbsolutePos.Y + btnSize.Y + 2
            )
            
            DropList.Size = UDim2.new(0, btnSize.X, 0, #options * 25)
        end

        local outsideClickConnection = nil

        local function openDropdown()
            updateDropdownPosition()
            DropList.Visible = true
            
            for _, option in ipairs(options) do
                if optionButtons[option] then
                    optionButtons[option].Visible = true
                end
            end
            
            if outsideClickConnection then
                outsideClickConnection:Disconnect()
            end
            
            outsideClickConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    local mousePos = input.Position
                    local dropListAbsPos = DropList.AbsolutePosition
                    local dropListSize = DropList.AbsoluteSize
                    local dropBtnAbsPos = DropBtn.AbsolutePosition
                    local dropBtnSize = DropBtn.AbsoluteSize
                    
                    local inDropList = mousePos.X >= dropListAbsPos.X and mousePos.X <= dropListAbsPos.X + dropListSize.X and
                                     mousePos.Y >= dropListAbsPos.Y and mousePos.Y <= dropListAbsPos.Y + dropListSize.Y
                                     
                    local inDropBtn = mousePos.X >= dropBtnAbsPos.X and mousePos.X <= dropBtnAbsPos.X + dropBtnSize.X and
                                    mousePos.Y >= dropBtnAbsPos.Y and mousePos.Y <= dropBtnAbsPos.Y + dropBtnSize.Y

                    if not inDropList and not inDropBtn then
                        DropList.Visible = false
                        if outsideClickConnection then
                            outsideClickConnection:Disconnect()
                        end
                    end
                end
            end)
        end

        DropBtn.MouseButton1Click:Connect(function()
            if DropList.Visible then
                DropList.Visible = false
                if outsideClickConnection then
                    outsideClickConnection:Disconnect()
                end
            else
                openDropdown()
            end
        end)

        Dropdown.Destroying:Connect(function()
            if outsideClickConnection then
                outsideClickConnection:Disconnect()
            end
            if DropList then
                DropList:Destroy()
            end
        end)

        return Dropdown
    end
    
    function Tab:AddTextbox(text, placeholder, callback)
        local Textbox = Instance.new("Frame")
        Textbox.Size = UDim2.new(1, 0, 0, 32)
        Textbox.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        Textbox.BorderSizePixel = 0
        Textbox.Parent = currentColumn
        
        local TextboxCorner = Instance.new("UICorner")
        TextboxCorner.CornerRadius = UDim.new(0, 6)
        TextboxCorner.Parent = Textbox
        
        local Label = Instance.new("TextLabel")
        Label.Size = UDim2.new(0, 100, 1, 0)
        Label.Position = UDim2.new(0, 10, 0, 0)
        Label.BackgroundTransparency = 1
        Label.Text = text
        Label.Font = Enum.Font.FredokaOne
        Label.TextSize = 11
        Label.TextColor3 = Color3.fromRGB(190, 190, 190)
        Label.TextXAlignment = Enum.TextXAlignment.Left
        Label.Parent = Textbox
        
        local Input = Instance.new("TextBox")
        Input.Size = UDim2.new(1, -120, 0, 22)
        Input.Position = UDim2.new(0, 115, 0.5, -11)
        Input.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        Input.BorderSizePixel = 0
        Input.Text = ""
        Input.PlaceholderText = placeholder or "Enter text..."
        Input.Font = Enum.Font.FredokaOne
        Input.TextSize = 10
        Input.TextColor3 = Color3.fromRGB(220, 220, 220)
        Input.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
        Input.ClearTextOnFocus = false
        Input.Parent = Textbox
        
        local InputCorner = Instance.new("UICorner")
        InputCorner.CornerRadius = UDim.new(0, 4)
        InputCorner.Parent = Input
        
        Input.FocusLost:Connect(function(enterPressed)
            if enterPressed and callback then
                pcall(callback, Input.Text)
            end
        end)
        
        return Textbox
    end
    
    function Tab:AddButton(text, callback)
        local Button = Instance.new("Frame")
        Button.Size = UDim2.new(1, 0, 0, 35)
        Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        Button.BorderSizePixel = 0
        Button.Parent = currentColumn
        
        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 6)
        ButtonCorner.Parent = Button
        
        local Btn = Instance.new("TextButton")
        Btn.Size = UDim2.new(1, -10, 1, -6)
        Btn.Position = UDim2.new(0, 5, 0, 3)
        Btn.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        Btn.BorderSizePixel = 0
        Btn.Text = text
        Btn.Font = Enum.Font.FredokaOne
        Btn.TextSize = 11
        Btn.TextColor3 = Color3.fromRGB(200, 200, 200)
        Btn.AutoButtonColor = false
        Btn.Parent = Button
        
        local BtnCorner = Instance.new("UICorner")
        BtnCorner.CornerRadius = UDim.new(0, 4)
        BtnCorner.Parent = Btn
        
        Btn.MouseEnter:Connect(function()
            Tween(Btn, {BackgroundColor3 = ThemeColor}, 0.2)
            Tween(Btn, {TextColor3 = Color3.fromRGB(255, 255, 255)}, 0.2)
        end)
        
        Btn.MouseLeave:Connect(function()
            Tween(Btn, {BackgroundColor3 = Color3.fromRGB(25, 25, 25)}, 0.2)
            Tween(Btn, {TextColor3 = Color3.fromRGB(200, 200, 200)}, 0.2)
        end)
        
        Btn.MouseButton1Click:Connect(function()
            Tween(Btn, {Size = UDim2.new(1, -12, 1, -8)}, 0.1)
            task.wait(0.1)
            Tween(Btn, {Size = UDim2.new(1, -10, 1, -6)}, 0.1)
            
            if callback then
                pcall(callback)
            end
        end)
        
        return Button
    end
    
    function Tab:Show()
        task.wait(0.1)
        pcall(function()
            for _, frame in pairs(ContentArea:GetChildren()) do
                if frame:IsA("Frame") then frame.Visible = false end
            end
            
            for _, btn in pairs(TabsBar:GetChildren()) do
                if btn:IsA("TextButton") then
                    Tween(btn, {BackgroundColor3 = Color3.fromRGB(18, 18, 18)})
                    Tween(btn, {TextColor3 = Color3.fromRGB(130, 130, 130)})
                    local ind = btn:FindFirstChild("Indicator")
                    if ind then ind.Visible = false end
                end
            end
            
            TabContent.Visible = true
            Indicator.Visible = true
            Tween(TabBtn, {BackgroundColor3 = Color3.fromRGB(25, 25, 25)})
            Tween(TabBtn, {TextColor3 = Color3.fromRGB(255, 255, 255)})
        end)
    end
    
    return Tab
end

-- ==================== EXEMPLO DE USO ====================
local Tab1  = Library:CreateTab("FARM")
local Tab2  = Library:CreateTab("AUTO")
local Tab3  = Library:CreateTab("PLAYER")
local Tab4  = Library:CreateTab("MOVEMENT")
local Tab5  = Library:CreateTab("VISUAL")
local Tab6  = Library:CreateTab("COMBAT")
local Tab7  = Library:CreateTab("WORLD")
local Tab8  = Library:CreateTab("MISC")
local Tab9  = Library:CreateTab("EXPLOITS")
local Tab10 = Library:CreateTab("SETTINGS")
local Tab11 = Library:CreateTab("CONFIG")
local Tab12 = Library:CreateTab("DEBUG")


-- TAB 1 - Exemplo
Tab1:AddSection("AUTO FARM", "left")

-- ==================== VARIÃVEIS GLOBAIS AUTO CAST ====================
local autoCastEnabled = false
local autoCastConnections = {}
local autoCastThread = nil
local isCasting = false
local lastCastTime = 0
local CAST_COOLDOWN = 2 -- segundos entre casts

-- ==================== VARIÃVEIS GLOBAIS AUTO SHAKE ====================
local autoShakeEnabled = false
local autoShakeConnections = {}
local autoShakeThreads = {}

-- ==================== VARIÃVEIS GLOBAIS AUTO RELL ====================
local autoRellEnabled = false
local autoRellConnection = nil

-- ==================== FUNÃ‡Ã•ES AUTO CAST OTIMIZADO ====================
local function limparAutoCast()
    for _, conn in pairs(autoCastConnections) do
        pcall(function() conn:Disconnect() end)
    end
    table.clear(autoCastConnections)
    
    if autoCastThread then
        pcall(function() task.cancel(autoCastThread) end)
        autoCastThread = nil
    end
    
    isCasting = false
    lastCastTime = 0
end

local function iniciarAutoCast()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = Players.LocalPlayer
    local mouse = player:GetMouse()
    local playerGui = player:WaitForChild("PlayerGui")

    -- animaÃ§Ã£o throw
    local throwAnim = ReplicatedStorage
        .resources
        .animations
        .fishing
        :WaitForChild("throw")

    local cachedTool
    local cachedCast

    -- verifica se tem GUI de pesca ativa
    local function hasFishingGui()
        local hasReel = playerGui:FindFirstChild("reel") ~= nil
        local hasShake = playerGui:FindFirstChild("shake") ~= nil
        return hasReel or hasShake
    end

    -- verifica se tem a tool de pesca equipada
    local function hasFishingTool()
        local char = player.Character
        if not char then return false end
        
        local tool = char:FindFirstChildOfClass("Tool")
        if not tool then return false end
        
        -- verifica se Ã© realmente uma tool de pesca
        local events = tool:FindFirstChild("events")
        if not events or not events:FindFirstChild("castAsync") then
            return false
        end
        
        return true
    end

    -- atualiza o cache da tool e do evento
    local function updateCache()
        if not autoCastEnabled then return false end
        
        local char = player.Character
        if not char then return false end

        cachedTool = char:FindFirstChildOfClass("Tool")
        if not cachedTool then 
            cachedCast = nil
            return false 
        end

        local events = cachedTool:FindFirstChild("events")
        cachedCast = events and events:FindFirstChild("castAsync")

        return cachedCast ~= nil
    end

    -- toca a animaÃ§Ã£o de arremesso
    local function playThrowAnimation()
        local char = player.Character
        if not char then return end
        
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        local track = humanoid:LoadAnimation(throwAnim)
        track.Priority = Enum.AnimationPriority.Action3
        track:Play()
    end

    -- funÃ§Ã£o principal de cast com todas as verificaÃ§Ãµes
    local function cast()
        if not autoCastEnabled then return end
        
        -- verifica cooldown
        local currentTime = tick()
        if currentTime - lastCastTime < CAST_COOLDOWN then
            return
        end
        
        -- se jÃ¡ tÃ¡ castando, espera
        if isCasting then return end
        
        -- se tÃ¡ pescando (tem GUI), nÃ£o faz nada
        if hasFishingGui() then return end
        
        -- verifica se tem a tool equipada
        if not hasFishingTool() then return end
        
        -- atualiza cache se necessÃ¡rio
        if not cachedCast then
            if not updateCache() then return end
        end
        
        local char = player.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then return end
        
        -- marca como castando
        isCasting = true
        lastCastTime = currentTime
        
        -- animaÃ§Ã£o de arremesso
        playThrowAnimation()
        
        -- calcula distÃ¢ncia e poder
        local distance = (mouse.Hit.Position - char.HumanoidRootPart.Position).Magnitude
        local power = math.clamp(distance, 0, 100)
        
        -- tenta fazer o cast
        local success = pcall(function()
            if autoCastEnabled then
                cachedCast:InvokeServer(power)
            end
        end)
        
        if not success then
            cachedCast = nil
        end
        
        -- espera um pouco antes de permitir novo cast
        task.delay(1, function()
            isCasting = false
        end)
    end
    
    -- monitora quando a tool Ã© equipada/desequipada
    local function monitorTool()
        if not autoCastEnabled then return end
        
        local char = player.Character
        if not char then return end

        table.insert(autoCastConnections, char.ChildAdded:Connect(function(child)
            if not autoCastEnabled then return end
            if child:IsA("Tool") then
                task.wait(0.2)
                updateCache()
            end
        end))

        table.insert(autoCastConnections, char.ChildRemoved:Connect(function(child)
            if not autoCastEnabled then return end
            if child:IsA("Tool") and child == cachedTool then
                cachedCast = nil
                cachedTool = nil
                isCasting = false
            end
        end))

        updateCache()
    end

    if player.Character then
        monitorTool()
    end
    
    table.insert(autoCastConnections, player.CharacterAdded:Connect(function()
        if not autoCastEnabled then return end
        cachedCast = nil
        cachedTool = nil
        isCasting = false
        monitorTool()
    end))

    -- monitora mudanÃ§as na GUI pra saber quando terminou de pescar
    table.insert(autoCastConnections, playerGui.ChildRemoved:Connect(function(child)
        if not autoCastEnabled then return end
        if child.Name == "reel" or child.Name == "shake" then
            -- GUI de pesca removida, pode castar de novo em breve
            isCasting = false
        end
    end))

    -- loop principal (checagem mais espaÃ§ada)
    autoCastThread = task.spawn(function()
        print("ðŸŽ£ AUTO CAST INTELIGENTE ativado")
        print("âš™ï¸ Cooldown entre casts:", CAST_COOLDOWN, "segundos")
        
        while autoCastEnabled do
            if not isCasting and not hasFishingGui() and hasFishingTool() then
                cast()
            end
            task.wait(1) -- checagem a cada 1 segundo
        end
        limparAutoCast()
    end)
end

-- ==================== FUNÃ‡Ã•ES AUTO SHAKE ====================
local function limparAutoShake()
    for _, conn in pairs(autoShakeConnections) do
        pcall(function() conn:Disconnect() end)
    end
    table.clear(autoShakeConnections)
    
    for _, thread in pairs(autoShakeThreads) do
        pcall(function() task.cancel(thread) end)
    end
    table.clear(autoShakeThreads)
end

local function iniciarAutoShake()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    local INTERVALO = 0.1
    local activeShakeGuis = {}

    local function iniciarAutoClick(shakeUI)
        if not autoShakeEnabled then return end
        if activeShakeGuis[shakeUI] then return end
        
        activeShakeGuis[shakeUI] = true
        print("âœ… ShakeUI detectada, iniciando cliques")

        local safezone = shakeUI:WaitForChild("safezone", 5)
        if not safezone then 
            activeShakeGuis[shakeUI] = nil
            return 
        end

        local remotes = {}

        local function atualizar()
            if not autoShakeEnabled then return end
            table.clear(remotes)
            for _, obj in ipairs(safezone:GetChildren()) do
                if obj:IsA("TextButton") or obj:IsA("ImageButton") then
                    local r = obj:FindFirstChild("shake")
                    if r and r:IsA("RemoteEvent") then
                        table.insert(remotes, r)
                    end
                end
            end
        end

        atualizar()
        
        table.insert(autoShakeConnections, safezone.ChildAdded:Connect(function()
            if autoShakeEnabled then atualizar() end
        end))
        
        table.insert(autoShakeConnections, safezone.ChildRemoved:Connect(function()
            if autoShakeEnabled then atualizar() end
        end))

        local clickThread = task.spawn(function()
            while autoShakeEnabled and shakeUI and shakeUI.Parent do
                for _, remote in ipairs(remotes) do
                    if not autoShakeEnabled then break end
                    pcall(function()
                        remote:FireServer()
                    end)
                end
                task.wait(INTERVALO)
            end

            print("ðŸ—‘ï¸ ShakeUI finalizada")
            activeShakeGuis[shakeUI] = nil
        end)
        
        autoShakeThreads[shakeUI] = clickThread
    end

    table.insert(autoShakeConnections, playerGui.ChildAdded:Connect(function(child)
        if not autoShakeEnabled then return end
        if child.Name:lower() == "shakeui" then
            iniciarAutoClick(child)
        end
    end))

    local existente = playerGui:FindFirstChild("shakeui")
    if existente then
        iniciarAutoClick(existente)
    end
end

-- ==================== FUNÃ‡Ã•ES AUTO RELL ====================
local function limparAutoRell()
    if autoRellConnection then
        pcall(function() autoRellConnection:Disconnect() end)
        autoRellConnection = nil
    end
end

local function iniciarAutoRell()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    local lastReelGui = nil
    local fishModified = false

    local function modificarFish(reelGui)
        if not autoRellEnabled then return end
        if lastReelGui == reelGui and fishModified then return end

        local success = pcall(function()
            local bar = reelGui:FindFirstChild("bar")
            if not bar then return end

            local fish = bar:FindFirstChild("fish")
            if not fish then return end

            fish.Size = UDim2.new(1000, 0, 1.2, 0)
            fish.Position = UDim2.new(0.5, 0, 0.5, 0)
            fish.AnchorPoint = Vector2.new(0.5, 0.5)
            fish.BackgroundTransparency = 0

            if fish:IsA("ImageLabel") or fish:IsA("ImageButton") then
                fish.ImageTransparency = 0
            end

            lastReelGui = reelGui
            fishModified = true
            print("ðŸŸ Fish modificado")
        end)

        if not success then
            fishModified = false
        end
    end

    autoRellConnection = RunService.Heartbeat:Connect(function()
        if not autoRellEnabled then
            limparAutoRell()
            return
        end

        local reelGui = playerGui:FindFirstChild("reel") or playerGui:FindFirstChild("Rell")
        
        if reelGui then
            if lastReelGui ~= reelGui then
                fishModified = false
            end
            modificarFish(reelGui)
        else
            lastReelGui = nil
            fishModified = false
        end
    end)
end

-- ==================== TOGGLES ====================
Tab1:AddToggle("AUTO CAST", false, function(v)
    autoCastEnabled = v
    
    if not v then
        print("ðŸ›‘ AUTO CAST OFF")
        limparAutoCast()
        return
    end

    print("ðŸŽ£ AUTO CAST ON")
    limparAutoCast()
    iniciarAutoCast()
end)

Tab1:AddToggle("AUTO SHAKE", false, function(v)
    autoShakeEnabled = v
    
    if not v then
        print("ðŸ›‘ AUTO SHAKE OFF")
        limparAutoShake()
        return
    end

    print("ðŸŽ¯ AUTO SHAKE ON")
    limparAutoShake()
    iniciarAutoShake()
end)

Tab1:AddToggle("AUTO RELL", false, function(v)
    autoRellEnabled = v
    
    if not v then
        print("ðŸ›‘ AUTO RELL OFF")
        limparAutoRell()
        return
    end

    print("ðŸŽ£ AUTO RELL ON")
    limparAutoRell()
    iniciarAutoRell()
end)

Tab1:AddSection("More Examples", "right")
Tab1:AddTextbox("Example Textbox", "Type here...", function(text)
    print("Textbox:", text)
end)

Tab1:AddButton("Example Button", function()
    print("Button clicked!")
end)
 
Tab1:AddToggle("ANTI AFK", false, function(v)
    if not v then
        print("ðŸ›‘ ANTI AFK OFF")
        return
    end

    print("ðŸ›¡ï¸ ANTI AFK ON")

    local Players = game:GetService("Players")
    local VirtualUser = game:GetService("VirtualUser")
    local player = Players.LocalPlayer

    -- conexÃ£o do evento Idled
    local connection
    connection = player.Idled:Connect(function()
        if not v then
            connection:Disconnect()
            return
        end

        -- simula atividade sem mexer na tool
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new(0, 0))
    end)
 end)
 
Tab2:AddSlider("UI Transparency", 0, 25, UITransparency * 100, function(v)
    UITransparency = v / 100
    ConfigManager.CurrentConfig.Theme.Transparency = UITransparency
    
    pcall(function()
        Main.BackgroundTransparency = UITransparency
        TopBar.BackgroundTransparency = UITransparency
        TopBarCover.BackgroundTransparency = UITransparency
        TabsBar.BackgroundTransparency = UITransparency
    end)
end)

-- Mostrar primeira tab (quando a GUI for aberta)
-- Tab1:Show() -- Removido porque a GUI nÃ£o abre mais automaticamente

print("âœ… Fisch Menu Carregado")
print("ðŸ“ Config: " .. ConfigManager.ConfigPath)

return Library
